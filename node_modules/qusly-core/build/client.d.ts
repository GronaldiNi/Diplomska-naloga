/// <reference types="node" />
import { EventEmitter } from 'events';
import { Writable, Readable } from 'stream';
import { IConfig, IClientOptions, IStrategiesMap, IFile, IClientWorkerGroup, ITransferProgressListener, ITransfer, ITaskHandler, IOptions, IFtpConfig, IFtpOptions, ISFtpOptions, ISFtpConfig, ITransferDirection } from './interfaces';
import { Strategy } from './strategies/strategy';
import { TasksManager } from './tasks';
declare type IClientEvents = 'connect' | 'disconnect' | 'transfer-new' | 'transfer-abort' | 'transfer-finish' | 'transfer-progress';
export declare interface Client {
    on(event: 'connect', listener: () => void): this;
    on(event: 'disconnect', listener: () => void): this;
    on(event: 'transfer-new', listener: (e: ITransfer) => void): this;
    on(event: 'transfer-abort', listener: (...ids: number[]) => void): this;
    on(event: 'transfer-finish', listener: (e: ITransfer) => void): this;
    on(event: 'transfer-progress', listener: ITransferProgressListener): this;
    once(event: 'connect', listener: () => void): this;
    once(event: 'disconnect', listener: () => void): this;
    once(event: 'transfer-new', listener: (e: ITransfer) => void): this;
    once(event: 'transfer-abort', listener: (...ids: number[]) => void): this;
    once(event: 'transfer-finish', listener: (e: ITransfer) => void): this;
    once(event: 'transfer-progress', listener: ITransferProgressListener): this;
    addListener(event: IClientEvents, listener: Function): this;
    removeListener(event: IClientEvents, listener: Function): this;
}
/**
 * High-level API, which handles strategies.
 *
 * It allows to call methods asynchronously.
 */
export declare class Client extends EventEmitter {
    protected _config?: IConfig;
    protected _connectionOptions?: IOptions;
    protected options: IClientOptions;
    protected workers: Strategy[];
    protected tasks: TasksManager<Strategy>;
    protected transfers: Map<number, number>;
    protected strategy: typeof Strategy;
    protected strategies: IStrategiesMap;
    /**
     * Previously set config.
     */
    get config(): IConfig;
    /**
     * You can set a pool of clients, which will create multiple channels for faster communication.
     */
    constructor(options?: IClientOptions);
    registerProtocol(protocol: string, strategy: typeof Strategy): void;
    unregisterProtocol(protocol: string): void;
    protected createWorker(): any;
    protected setWorkers(): void;
    protected handleWorkerEvents: (instance: Strategy) => void;
    protected clearWorkerEvents: (instance: Strategy) => void;
    protected setWorkerGroups(): void;
    protected getWorkerInstance: (index: number) => Strategy;
    protected workerFilter: (worker: any, group: IClientWorkerGroup) => boolean;
    /**
     * Connects to a server. If you're already connected, it disconnects.
     *
     * It saves `config` and `options`, so you can call it without providing these arguments later.
     */
    connect(config?: IFtpConfig, options?: IFtpOptions): any;
    connect(config?: ISFtpConfig, options?: ISFtpOptions): any;
    disconnect(): Promise<void>;
    /**
     * Aborts every proccesed and waiting task.
     */
    abort(): Promise<void>;
    /**
     * Aborts specified file transfers.
     */
    abortTransfer(...transferIds: number[]): Promise<void>;
    /**
     * Downloads a remote file.
     *
     * @param dest can be either `Writable` stream or path of a local file.
     * @param startAt can be set to resume download.
     */
    download(dest: Writable | string, remotePath: string, startAt?: number): Promise<void>;
    /**
     * Uploads a local file.
     *
     * @param source can be either `Readable` stream or path of a remote file.
     */
    upload(source: Readable | string, remotePath: string): Promise<void>;
    /**
     * Lists files in a folder.
     */
    list(path?: string): Promise<IFile[]>;
    /**
     * Gets size of a file.
     */
    size(path: string): Promise<number>;
    /**
     * Checks if a file or a folder exists.
     */
    exists(path: string): Promise<boolean>;
    /**
     * Moves a file or a folder.
     * Can be used to rename.
     */
    move(source: string, dest: string): Promise<void>;
    removeFile(path: string): Promise<void>;
    removeEmptyFolder(path: string): Promise<void>;
    /**
     * Removes a folder and all of its content.
     */
    removeFolder(path: string): Promise<void>;
    createFolder(path: string): Promise<void>;
    /**
     * Creates an empty file. Similar to `touch` in Unix.
     */
    createEmptyFile(path: string): Promise<void>;
    /**
     * Gets current working directory.
     */
    pwd(): Promise<string>;
    /**
     * Sends a raw command. Support not guaranteed.
     */
    send(command: string): Promise<string>;
    protected onConnect: () => void;
    protected onDisconnect: () => void;
    protected onProgress: (data: any, progress: any) => void;
    protected handleTransfer(fn: ITaskHandler<Strategy>, direction: ITransferDirection): Promise<void>;
}
export {};
